/**
 * This file is auto-generated by the `asana-api-meta` NodeJS package.
 * We try to keep the generated code pretty clean but there will be lint
 * errors that are just not worth fixing (like unused requires).
 * TODO: maybe we can just disable those specifically and keep this code
 * pretty lint-free too!
 */
/* jshint ignore:start */
var Resource = require('../resource');
var util = require('util');
var _ = require('lodash');

/**
 * The _task_ is the basic object around which many operations in Asana are
 * centered. In the Asana application, multiple tasks populate the middle pane
 * according to some view parameters, and the set of selected tasks determines
 * the more detailed information presented in the details pane.
 * @class
 * @param {Dispatcher} dispatcher The API dispatcher
 */
function Tasks(dispatcher) {
  Resource.call(this, dispatcher);
}
util.inherits(Tasks, Resource);


/**
 * Creating a new task is as easy as POSTing to the `/tasks` endpoint
 * with a data block containing the fields you'd like to set on the task.
 * Any unspecified fields will take on default values.
 * 
 * Every task is required to be created in a specific workspace, and this
 * workspace cannot be changed once set. The workspace need not be set
 * explicitly if you specify `projects` or a `parent` task instead.
 * 
 * `projects` can be a comma separated list of projects, or just a single
 * project the task should belong to.
   * @param {Object} data Data for the request
   * @param {String} [data.workspace] The workspace to create a task in.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.create = function(
    data,
    dispatchOptions
) {
  var path = util.format('/tasks');
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Creating a new task is as easy as POSTing to the `/tasks` endpoint
 * with a data block containing the fields you'd like to set on the task.
 * Any unspecified fields will take on default values.
 * 
 * Every task is required to be created in a specific workspace, and this
 * workspace cannot be changed once set. The workspace need not be set
 * explicitly if you specify a `project` or a `parent` task instead.
   * @param {String} workspace The workspace to create a task in.
   * @param {Object} data Data for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.createInWorkspace = function(
    workspace,
    data,
    dispatchOptions
) {
  var path = util.format('/workspaces/%s/tasks', workspace);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Returns the complete task record for a single task.
   * @param {String} task The task to get.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The requested resource
 */
Tasks.prototype.findById = function(
    task,
    params,
    dispatchOptions
) {
  var path = util.format('/tasks/%s', task);
  
  return this.dispatchGet(path, params, dispatchOptions);
};

/**
 * A specific, existing task can be updated by making a PUT request on the
 * URL for that task. Only the fields provided in the `data` block will be
 * updated; any unspecified fields will remain unchanged.
 * 
 * When using this method, it is best to specify only those fields you wish
 * to change, or else you may overwrite changes made by another user since
 * you last retrieved the task.
 * 
 * Returns the complete updated task record.
   * @param {String} task The task to update.
   * @param {Object} data Data for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.update = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s', task);
  
  return this.dispatchPut(path, data, dispatchOptions);
};

/**
 * A specific, existing task can be deleted by making a DELETE request on the
 * URL for that task. Deleted tasks go into the "trash" of the user making
 * the delete request. Tasks can be recovered from the trash within a period
 * of 30 days; afterward they are completely removed from the system.
 * 
 * Returns an empty data record.
   * @param {String} task The task to delete.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.delete = function(
    task,
    dispatchOptions
) {
  var path = util.format('/tasks/%s', task);
  
  return this.dispatchDelete(path, dispatchOptions);
};

/**
 * Returns the compact task records for all tasks within the given project,
 * ordered by their priority within the project.
   * @param {String} projectId The project in which to search for tasks.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.findByProject = function(
    projectId,
    params,
    dispatchOptions
) {
  var path = util.format('/projects/%s/tasks', projectId);
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * Returns the compact task records for all tasks with the given tag.
   * @param {String} tag The tag in which to search for tasks.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.findByTag = function(
    tag,
    params,
    dispatchOptions
) {
  var path = util.format('/tags/%s/tasks', tag);
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * <b>Board view only:</b> Returns the compact section records for all tasks within the given section.
   * @param {String} section The section in which to search for tasks.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.findBySection = function(
    section,
    params,
    dispatchOptions
) {
  var path = util.format('/sections/%s/tasks', section);
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * Returns the compact task records for some filtered set of tasks. Use one
 * or more of the parameters provided to filter the tasks returned. You must
 * specify a `project` or `tag` if you do not specify `assignee` and `workspace`.
   * @param {Object} [params] Parameters for the request
   * @param {String} [params.assignee] The assignee to filter tasks on.
   * @param {String} [params.project] The project to filter tasks on.
   * @param {String} [params.section] The section to filter tasks on.
   * @param {String} [params.workspace] The workspace or organization to filter tasks on.
   * @param {String} [params.completed_since] Only return tasks that are either incomplete or that have been
   * completed since this time.
   * @param {String} [params.modified_since] Only return tasks that have been modified since the given time.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.findAll = function(
    params,
    dispatchOptions
) {
  var path = util.format('/tasks');
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * Adds each of the specified followers to the task, if they are not already
 * following. Returns the complete, updated record for the affected task.
   * @param {String} task The task to add followers to.
   * @param {Object} data Data for the request
   * @param {Array} data.followers An array of followers to add to the task.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.addFollowers = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/addFollowers', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Removes each of the specified followers from the task if they are
 * following. Returns the complete, updated record for the affected task.
   * @param {String} task The task to remove followers from.
   * @param {Object} data Data for the request
   * @param {Array} data.followers An array of followers to remove from the task.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.removeFollowers = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/removeFollowers', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Returns a compact representation of all of the projects the task is in.
   * @param {String} task The task to get projects on.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.projects = function(
    task,
    params,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/projects', task);
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * Adds the task to the specified project, in the optional location
 * specified. If no location arguments are given, the task will be added to
 * the end of the project.
 * 
 * `addProject` can also be used to reorder a task within a project or section that
 * already contains it.
 * 
 * At most one of `insert_before`, `insert_after`, or `section` should be
 * specified. Inserting into a section in an non-order-dependent way can be
 * done by specifying `section`, otherwise, to insert within a section in a
 * particular place, specify `insert_before` or `insert_after` and a task
 * within the section to anchor the position of this task.
 * 
 * Returns an empty data block.
   * @param {String} task The task to add to a project.
   * @param {Object} data Data for the request
   * @param {String} data.project The project to add the task to.
   * @param {String} [data.insert_after] A task in the project to insert the task after, or `null` to
   * insert at the beginning of the list.
   * @param {String} [data.insert_before] A task in the project to insert the task before, or `null` to
   * insert at the end of the list.
   * @param {String} [data.section] A section in the project to insert the task into. The task will be
   * inserted at the bottom of the section.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.addProject = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/addProject', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Removes the task from the specified project. The task will still exist
 * in the system, but it will not be in the project anymore.
 * 
 * Returns an empty data block.
   * @param {String} task The task to remove from a project.
   * @param {Object} data Data for the request
   * @param {String} data.project The project to remove the task from.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.removeProject = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/removeProject', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Returns a compact representation of all of the tags the task has.
   * @param {String} task The task to get tags on.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.tags = function(
    task,
    params,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/tags', task);
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * Adds a tag to a task. Returns an empty data block.
   * @param {String} task The task to add a tag to.
   * @param {Object} data Data for the request
   * @param {String} data.tag The tag to add to the task.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.addTag = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/addTag', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Removes a tag from the task. Returns an empty data block.
   * @param {String} task The task to remove a tag from.
   * @param {Object} data Data for the request
   * @param {String} data.tag The tag to remove from the task.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.removeTag = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/removeTag', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Returns a compact representation of all of the subtasks of a task.
   * @param {String} task The task to get the subtasks of.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.subtasks = function(
    task,
    params,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/subtasks', task);
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * Creates a new subtask and adds it to the parent task. Returns the full record
 * for the newly created subtask.
   * @param {String} task The task to add a subtask to.
   * @param {Object} data Data for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.addSubtask = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/subtasks', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};

/**
 * Returns a compact representation of all of the stories on the task.
   * @param {String} task The task containing the stories to get.
   * @param {Object} [params] Parameters for the request
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.stories = function(
    task,
    params,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/stories', task);
  
  return this.dispatchGetCollection(path, params, dispatchOptions);
};

/**
 * Adds a comment to a task. The comment will be authored by the
 * currently authenticated user, and timestamped when the server receives
 * the request.
 * 
 * Returns the full record for the new story added to the task.
   * @param {String} task Globally unique identifier for the task.
   * @param {Object} data Data for the request
   * @param {String} data.text The plain text of the comment to add.
   * @param {Object} [dispatchOptions] Options, if any, to pass the dispatcher for the request
   * @return {Promise} The response from the API
 */
Tasks.prototype.addComment = function(
    task,
    data,
    dispatchOptions
) {
  var path = util.format('/tasks/%s/stories', task);
  
  return this.dispatchPost(path, data, dispatchOptions);
};


module.exports = Tasks;
/* jshint ignore:end */